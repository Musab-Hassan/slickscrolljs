{"version":3,"file":"build.js","mappings":";;;;;;;;;;;;;;;;;AAAA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA,MAAM,+CAA+C;AACrD,MAAM,gDAAgD;AACtD,MAAM,kDAAkD;AACxD;AACA,MAAM,8CAA8C;AACpD,MAAM,+CAA+C;AACrD,MAAM,kDAAkD;AACxD;AACA,MAAM,gDAAgD;AACtD,MAAM,iDAAiD;AACvD,MAAM,mDAAmD;AACzD;AACA,MAAM,+CAA+C;AACrD,MAAM,gDAAgD;AACtD,MAAM,mDAAmD;AACzD;AACA,MAAM,gDAAgD;AACtD,MAAM,iDAAiD;AACvD,MAAM,mDAAmD;AACzD;AACA,MAAM,8CAA8C;AACpD,MAAM,+CAA+C;AACrD,MAAM,kDAAkD;AACxD;AACA,MAAM,+CAA+C;AACrD,MAAM,gDAAgD;AACtD,MAAM;AACN;;;;;;;;;;;;;;;;;AC5CA;AACA;AACqJ;AAChG;AACrD;AACA;AACO;AACP;AACA,8BAA8B,EAAE,+CAAQ;AACxC;AACA;AACA,mBAAmB,kDAAU;AAC7B;AACA,IAAI,sDAAc;AAClB,IAAI,sDAAc;AAClB;AACA;AACA,iCAAiC,0DAAkB;AACnD;AACA,gCAAgC,0DAAkB;AAClD;AACA;AACA;AACA,wCAAwC,EAAE,oDAAa;AACvD,8CAA8C,yCAAyC,MAAM,wCAAwC;AACrI,mCAAmC,kDAAU;AAC7C;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA,+BAA+B,kDAAU;AACzC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,4BAA4B,0DAAkB;AAC9C,iCAAiC,0DAAkB;AACnD;AACA,eAAe;AACf;AACA,mBAAmB;AACnB;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA,+CAA+C,WAAW,MAAM,WAAW;AAC3E;AACA;AACA;AACA;AACA,gCAAgC,0BAA0B;AAC1D;AACA,wCAAwC,EAAE,oDAAa;AACvD,8CAA8C,4BAA4B,MAAM,4BAA4B;AAC5G,mCAAmC,kDAAU;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,+BAA+B;AAC/D,8CAA8C,gBAAgB,MAAM,gBAAgB;AACpF,mCAAmC,kDAAU;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,yBAAyB,yDAAiB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,sDAAkB;AACnD,iCAAiC,sDAAkB;AACnD;AACA;AACA,gCAAgC,YAAY;AAC5C;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,4BAA4B,0DAAkB;AAC9C,iCAAiC,0DAAkB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,OAAO;AACrD;AACA;AACA;AACA;AACA;AACA,QAAQ,kDAAU;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,kDAAU;AACvE;AACA,wDAAwD,kDAAU;AAClE;AACA;AACA;AACA;AACA;AACA,mCAAmC,kDAAU;AAC7C;AACA,mCAAmC,kDAAU;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,4BAA4B,0DAAkB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,EAAE,oDAAa;AAC7C,QAAQ,yDAAiB;AACzB;AACA;AACA;AACA,iCAAiC,0DAAkB;AACnD,aAAa,kDAAU;AACvB;AACA,QAAQ,yDAAiB;AACzB;AACA;AACA;AACA,yBAAyB,0DAAkB;AAC3C,8BAA8B,0DAAkB;AAChD;AACA;AACA;AACA,yCAAyC,6DAAqB,aAAa,kDAAU;AACrF,yCAAyC,6DAAqB;AAC9D;AACA;AACA,6CAA6C,6DAAqB,kBAAkB,kDAAU;AAC9F,6CAA6C,6DAAqB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,OAAO;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AC3RA;AACA;AAC0D;AAC1D;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,iBAAiB,0EAAoB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,uBAAuB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B,2BAA2B;AAC3B,sBAAsB;AACtB,wCAAwC;AACxC,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mEAAmE;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;UCxKA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACuD;AAClB;AACtB;AACf;AACA;AACA,8BAA8B,gEAAc;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kDAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://slickScroll/./src/momentumScroll/defaults.ts","webpack://slickScroll/./src/momentumScroll/main.ts","webpack://slickScroll/./src/utils.ts","webpack://slickScroll/webpack/bootstrap","webpack://slickScroll/webpack/runtime/define property getters","webpack://slickScroll/webpack/runtime/hasOwnProperty shorthand","webpack://slickScroll/webpack/runtime/make namespace object","webpack://slickScroll/./src/index.ts"],"sourcesContent":["/* Default values and properties for momentumScroll */\n// Default properties for momentumScrollStruct\nexport var defaults = {\n    root: \"body\",\n    duration: 1000,\n    easing: \"cubic-bezier(0.15, 1, 0.4, 1)\",\n    offsets: [],\n    fixedOffsets: []\n};\n// Default offset speeds\nexport var defaultSpeeds = {\n    speedY: 1,\n    speedX: 1\n};\n// Default pennerEasings\nexport var pennerEasings = [\n    // Sine\n    { name: \"easeInSine\", value: [0.12, 0, 0.39, 0] },\n    { name: \"easeOutSine\", value: [0.61, 1, 0.88, 1] },\n    { name: \"easeInOutSine\", value: [0.37, 0, 0.63, 1] },\n    // Quad\n    { name: \"easeInQuad\", value: [0.11, 0, 0.5, 0] },\n    { name: \"easeOutQuad\", value: [0.5, 1, 0.89, 1] },\n    { name: \"easeInOutQuad\", value: [0.45, 0, 0.55, 1] },\n    // Cubic\n    { name: \"easeInCubic\", value: [0.32, 0, 0.67, 0] },\n    { name: \"easeOutCubic\", value: [0.33, 1, 0.68, 1] },\n    { name: \"easeInOutCubic\", value: [0.65, 0, 0.35, 1] },\n    // Quart\n    { name: \"easeInQuart\", value: [0.5, 0, 0.75, 0] },\n    { name: \"easeOutQuart\", value: [0.25, 1, 0.5, 1] },\n    { name: \"easeInOutQuart\", value: [0.76, 0, 0.24, 1] },\n    // Quint\n    { name: \"easeInQuint\", value: [0.64, 0, 0.78, 0] },\n    { name: \"easeOutQuint\", value: [0.22, 1, 0.36, 1] },\n    { name: \"easeInOutQuint\", value: [0.83, 0, 0.17, 1] },\n    // Expo\n    { name: \"easeInExpo\", value: [0.7, 0, 0.84, 0] },\n    { name: \"easeOutExpo\", value: [0.16, 1, 0.3, 1] },\n    { name: \"easeInOutExpo\", value: [0.87, 0, 0.13, 1] },\n    // Circ\n    { name: \"easeInCirc\", value: [0.55, 0, 1, 0.45] },\n    { name: \"easeOutCirc\", value: [0, 0.55, 0.45, 1] },\n    { name: \"easeInOutCirc\", value: [0.85, 0, 0.15, 1] }\n];\n","/*         momentumScroll/main.ts          */\n/*  source of the momentumScroll function  */\nimport { getFromOffsetArray, pushToOffsetArray, removeFromOffsetArray, selectNode, setOffsetArray, bezierEasing, parseBezierString } from \"../utils\";\nimport { defaults, defaultSpeeds } from \"./defaults\";\nvar fixedOffsets = [];\nvar offsets = [];\nexport function momentumScroll(dataObj) {\n    // Assign defaults to dataObj object\n    dataObj = Object.assign({}, defaults, dataObj);\n    let pl;\n    let startStamp;\n    let rootElem = selectNode(dataObj.root);\n    // Set any offsets or fixedOffsets assigned on initialization\n    setOffsetArray(fixedOffsets, rootElem, dataObj.fixedOffsets);\n    setOffsetArray(offsets, rootElem, dataObj.offsets);\n    // if client is phone or unsupported\n    if (!isCompatible()) {\n        let activeFixedOffsets = getFromOffsetArray(fixedOffsets, rootElem);\n        rootElem.addEventListener(\"scroll\", (event) => {\n            let activeOffsets = getFromOffsetArray(offsets, rootElem);\n            // Offset elements scrolling\n            if (activeOffsets) {\n                activeOffsets.forEach((e) => {\n                    e = Object.assign({}, defaultSpeeds, e);\n                    let offset = `translate(${event.target.scrollLeft * (1 - e.speedX)}px, ${event.target.scrollTop * (1 - e.speedY)}px)`;\n                    let elements = selectNode(e.element, true);\n                    for (e of elements) {\n                        e.style.webkitTransform = offset;\n                        e.style.transform = offset;\n                    }\n                });\n            }\n        });\n        // Fixed elements\n        if (activeFixedOffsets) {\n            activeFixedOffsets.forEach((e) => {\n                let elements = selectNode(e, true);\n                for (e of elements) {\n                    e.style.position = \"fixed\";\n                }\n            });\n        }\n        return {\n            // TODO: Add mobile on Destroy\n            destroy: onDestroy,\n            removeOffset: removeOffset,\n            addOffset: addOffset,\n            addFixedOffset: addFixedOffset\n        };\n    }\n    // if not phone or unsupported then then ->\n    let fixedElem = DOMRestructure(rootElem);\n    let mutationObserver = new MutationObserver(onResize);\n    // Detect any changes to root element's appearance\n    window.addEventListener(\"resize\", onResize);\n    mutationObserver.observe(rootElem, {\n        childList: true,\n        attributes: true,\n        subtree: true\n    });\n    // Scroll handler\n    rootElem.addEventListener(\"scroll\", onScroll);\n    return {\n        destroy: onDestroy,\n        removeOffset: removeOffset,\n        addOffset: addOffset,\n        addFixedOffset: addFixedOffset\n    };\n    /* Event Handler Functions */\n    // Scroll handler\n    function onScroll(e) {\n        if (dataObj.onScroll)\n            dataObj.onScroll(e); // Run passed onScroll function\n        let activeOffsets = getFromOffsetArray(offsets, rootElem);\n        let activeFixedOffsets = getFromOffsetArray(fixedOffsets, rootElem);\n        // Get scroll location of rootElement\n        pl = { x: rootElem.scrollLeft, y: rootElem.scrollTop };\n        if (typeof pl.x === \"undefined\" || typeof pl.y === \"undefined\")\n            pl = { x: rootElem.scrollX, y: rootElem.scrollY, };\n        // Get transform coordinates of fixedElements\n        let style = window.getComputedStyle(fixedElem.fixed);\n        let matrix = new WebKitCSSMatrix(style.transform);\n        let tl = { x: matrix.m41, y: matrix.m42 };\n        // Current time for timing to work\n        startStamp = Date.now();\n        // Scroll Animation Frame Handler for easing\n        easeFrames(tl, pl, startStamp, (position) => {\n            let translateString = `translate(${position.x}px, ${position.y}px)`;\n            fixedElem.fixed.style.webkitTransform = translateString;\n            fixedElem.fixed.style.transform = translateString;\n            // Offset elements scrolling if there are any present\n            if (Array.isArray(activeOffsets)) {\n                for (let i = 0; i < activeOffsets.length; i++) {\n                    let e = activeOffsets[i];\n                    e = Object.assign({}, defaultSpeeds, e);\n                    let offset = `translate(${position.x * (e.speedX - 1)}px, ${position.y * (e.speedY - 1)}px)`;\n                    let elements = selectNode(e.element, true);\n                    if (NodeList.prototype.isPrototypeOf(elements)) {\n                        for (let e of elements) {\n                            e.style.webkitTransform = offset;\n                            e.style.transform = offset;\n                        }\n                    }\n                    else {\n                        elements.style.webkitTransform = offset;\n                        elements.style.transform = offset;\n                    }\n                }\n            }\n            // set fixedOffsets as fixed\n            if (Array.isArray(activeFixedOffsets)) {\n                for (let i = 0; i < activeFixedOffsets.length; i++) {\n                    let offset = `translate(${position.x * -1}px, ${position.y * -1}px)`;\n                    let elements = selectNode(activeFixedOffsets[i], true);\n                    if (NodeList.prototype.isPrototypeOf(elements)) {\n                        for (let e of elements) {\n                            e.style.webkitTransform = offset;\n                            e.style.transform = offset;\n                        }\n                    }\n                    else {\n                        elements.style.webkitTransform = offset;\n                        elements.style.transform = offset;\n                    }\n                }\n            }\n        });\n        // Returns calculated transform values based on scroll position\n        function easeFrames(tl, pl, startStamp, onIterate) {\n            // Parse bezier easing string into number values\n            let easing = parseBezierString(dataObj.easing);\n            let diffX = ((tl.x * -1) - pl.x);\n            let diffY = ((tl.y * -1) - pl.y);\n            let x, y;\n            // Animation frame loop\n            (function loop() {\n                let t = (Date.now() - startStamp) / dataObj.duration;\n                if (t > 1)\n                    t = 1.01;\n                if (t < 1) {\n                    x = (diffX * bezierEasing.apply(null, easing)(t)) + tl.x;\n                    y = (diffY * bezierEasing.apply(null, easing)(t)) + tl.y;\n                    x = Math.ceil(x * 100) / 100;\n                    y = Math.ceil(y * 100) / 100;\n                    onIterate({ x: x, y: y });\n                    window.requestAnimationFrame(loop);\n                }\n            }());\n        }\n    }\n    // Remove all slickScroll handers and return DOM to original state\n    function onDestroy() {\n        let activeOffsets = getFromOffsetArray(offsets, rootElem);\n        let activeFixedOffsets = getFromOffsetArray(fixedOffsets, rootElem);\n        let wrapper = rootElem.querySelector(\"._SS_wrapper\");\n        // Remove all Observers and EventListeners\n        rootElem.removeEventListener(\"scroll\", onScroll);\n        window.removeEventListener(\"resize\", onResize);\n        mutationObserver.disconnect();\n        // Revert root element to original state and remove all slickscroll classes\n        for (let i = wrapper.children.length; i > 0; i--) {\n            if (wrapper.children[i - 1].removeProperty)\n                wrapper.children[i - 1].removeProperty(\"transform\");\n            rootElem.insertBefore(wrapper.children[i - 1], rootElem.children[0]);\n        }\n        wrapper.remove();\n        selectNode(dataObj.root).querySelector(\"._SS_dummy\").remove();\n        rootElem.style.removeProperty(\"overflow\");\n        rootElem.style.removeProperty(\"position\");\n        // Clear all transformations on offsets\n        clearTransform(activeOffsets);\n        clearTransform(activeFixedOffsets);\n        // Purge instance from fixedOffsets and offsets arrays\n        let index;\n        index = fixedOffsets.findIndex(obj => obj.element == selectNode(dataObj.root));\n        fixedOffsets.splice(index, 1);\n        index = offsets.findIndex(obj => obj.element == selectNode(dataObj.root));\n        offsets.splice(index, 1);\n        // Remove \"transform\" from an offset array\n        function clearTransform(array) {\n            if (array) {\n                array.forEach((e) => {\n                    let elements = selectNode(e.element, true);\n                    if (!e.element)\n                        elements = selectNode(e, true);\n                    if (NodeList.prototype.isPrototypeOf(elements)) {\n                        for (e of elements) {\n                            e.style.removeProperty(\"transform\");\n                            e.style.removeProperty(\"-webkit-transform\");\n                        }\n                        return;\n                    }\n                    elements.style.removeProperty(\"transform\");\n                    elements.style.removeProperty(\"-webkit-transform\");\n                });\n            }\n        }\n    }\n    // Add Offsets after intialization\n    function addOffset(obj) {\n        let activeOffsets = getFromOffsetArray(offsets, rootElem);\n        if (typeof obj !== \"object\")\n            return;\n        // Check if offset already exists\n        const find = activeOffsets.find((i) => i.element == obj.element);\n        if (find || !obj.element)\n            return;\n        // Assign an offset and push it to offsets array\n        obj = Object.assign({}, defaultSpeeds, obj);\n        pushToOffsetArray(offsets, rootElem, obj);\n    }\n    // Add fixedOffsets after intialization\n    function addFixedOffset(element) {\n        let activeFixedOffsets = getFromOffsetArray(fixedOffsets, rootElem);\n        if (!selectNode(element, true) || activeFixedOffsets.includes(element))\n            return;\n        pushToOffsetArray(fixedOffsets, rootElem, element);\n    }\n    // Disable and remove an active Fixed or Regular Offset\n    function removeOffset(element) {\n        let activeItem = getFromOffsetArray(offsets, rootElem);\n        let activeFixedItem = getFromOffsetArray(fixedOffsets, rootElem);\n        let offsetIndex = offsets.findIndex((e) => e.element == rootElem);\n        let fixedIndex = fixedOffsets.findIndex((e) => e.element == rootElem);\n        if (activeItem.length > 0) {\n            offsets[offsetIndex].items = removeFromOffsetArray(activeItem, selectNode(element, true));\n            offsets[offsetIndex].items = removeFromOffsetArray(activeItem, element);\n        }\n        if (activeFixedItem.length > 0) {\n            fixedOffsets[fixedIndex].items = removeFromOffsetArray(activeFixedItem, selectNode(element, true));\n            fixedOffsets[fixedIndex].items = removeFromOffsetArray(activeFixedItem, element);\n        }\n    }\n    // Resize dummy element when window resizes to prevent overscrolling\n    function onResize() {\n        fixedElem.dummy.style.height = fixedElem.fixed.scrollHeight + \"px\";\n    }\n    // Adds fixed transformable child element to the root element\n    function DOMRestructure(root) {\n        // Make sure root doesnt already have a position\n        if (getComputedStyle(root).position != \"absolute\" || getComputedStyle(root).position != \"fixed\") {\n            root.style.position = \"relative\";\n        }\n        let child = document.createElement('div');\n        let dummy = document.createElement('div');\n        child.classList.add(\"_SS_wrapper\");\n        dummy.classList.add(\"_SS_dummy\");\n        for (let i = root.children.length; i > 0; i--) {\n            child.insertBefore(root.children[(i - 1)], child.children[0]);\n        }\n        root.innerHTML = \"\";\n        root.style.overflow = \"auto\";\n        root.appendChild(child);\n        root.appendChild(dummy);\n        // Dummy Scroll element to allow overflow to appear\n        dummy.style.height = child.scrollHeight + \"px\";\n        dummy.style.width = child.scrollWidth + \"px\";\n        dummy.style.top = \"0px\";\n        dummy.style.left = \"0px\";\n        dummy.style.position = \"absolute\";\n        dummy.style.zIndex = \"-9999\";\n        // Content inside the root element\n        child.style.zIndex = \"1\";\n        child.style.height = \"100%\";\n        child.style.width = \"100%\";\n        child.style.overflow = \"visible\";\n        child.style.top = \"0px\";\n        child.style.left = \"0px\";\n        child.style.position = \"sticky\";\n        return {\n            fixed: root.querySelector(\"div._SS_wrapper\"),\n            dummy: root.querySelector(\"div._SS_dummy\")\n        };\n    }\n    // Checks for mobile & unsupported browsers\n    function isCompatible() {\n        let check = false;\n        (function (a) { if (/(android|bb\\d+|meego).+mobile|avantgo|bada\\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\\-(n|u)|c55\\/|capi|ccwa|cdm\\-|cell|chtm|cldc|cmd\\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\\-s|devi|dica|dmob|do(c|p)o|ds(12|\\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\\-|_)|g1 u|g560|gene|gf\\-5|g\\-mo|go(\\.w|od)|gr(ad|un)|haie|hcit|hd\\-(m|p|t)|hei\\-|hi(pt|ta)|hp( i|ip)|hs\\-c|ht(c(\\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\\-(20|go|ma)|i230|iac( |\\-|\\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\\/)|klon|kpt |kwc\\-|kyo(c|k)|le(no|xi)|lg( g|\\/(k|l|u)|50|54|\\-[a-w])|libw|lynx|m1\\-w|m3ga|m50\\/|ma(te|ui|xo)|mc(01|21|ca)|m\\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\\-2|po(ck|rt|se)|prox|psio|pt\\-g|qa\\-a|qc(07|12|21|32|60|\\-[2-7]|i\\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\\-|oo|p\\-)|sdk\\/|se(c(\\-|0|1)|47|mc|nd|ri)|sgh\\-|shar|sie(\\-|m)|sk\\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\\-|v\\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\\-|tdg\\-|tel(i|m)|tim\\-|t\\-mo|to(pl|sh)|ts(70|m\\-|m3|m5)|tx\\-9|up(\\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\\-|your|zeto|zte\\-/i.test(a.substr(0, 4)))\n            check = true; })(navigator.userAgent || navigator.vendor);\n        if (!check && CSS.supports)\n            check = !CSS.supports(\"position\", \"sticky\");\n        return !check;\n    }\n}\n","/*             utils.ts                 */\n/* Globally accessible helper functions */\nimport { pennerEasings } from \"./momentumScroll/defaults\";\n// Initalize an array of fixedOffsets or offsets\nexport function setOffsetArray(array, id, data) {\n    let itemArr = array.filter(obj => obj.element == id);\n    if (itemArr.length > 0) {\n        if (data)\n            itemArr[0].items = data;\n        itemArr[0].element = id;\n    }\n    else {\n        let obj;\n        if (data) {\n            obj = { element: id, items: data };\n        }\n        else {\n            obj = { element: id };\n        }\n        array.push(obj);\n    }\n}\n// Push to an offsets or fixedOffsets Array\nexport function pushToOffsetArray(array, id, data) {\n    let index = array.findIndex(obj => obj.element == id);\n    array[index].items.push(data);\n}\n// Remove specific offset from fixedOffsets or offsets\nexport function removeFromOffsetArray(array, item) {\n    let index = array.findIndex(obj => obj.element == item || obj == item);\n    if (index > -1) {\n        let elements = array[index];\n        if (typeof elements == \"object\" && !elements.nodeName)\n            elements = elements.element;\n        elements = selectNode(elements, true);\n        if (NodeList.prototype.isPrototypeOf(elements)) {\n            for (let e of elements) {\n                e.style.removeProperty(\"transform\");\n                e.style.removeProperty(\"-webkit-transform\");\n                if (e.style.position == \"fixed\")\n                    e.style.removeProperty(\"position\");\n            }\n            return;\n        }\n        elements.style.removeProperty(\"transform\");\n        elements.style.removeProperty(\"-webkit-transform\");\n        if (elements.style.position == \"fixed\")\n            elements.style.removeProperty(\"position\");\n        array.splice(index, 1);\n    }\n    return array;\n}\n// Fetch an offset from fixedOffsets or offsets\nexport function getFromOffsetArray(array, id) {\n    let item = array.filter(obj => obj.element == id);\n    return item[0].items;\n}\n// Select the node if a query string is provided\nexport function selectNode(elem, multiple) {\n    // return node if element is string\n    if (typeof elem == \"string\") {\n        if (multiple) {\n            return document.querySelectorAll(elem);\n        }\n        else {\n            return document.querySelector(elem);\n        }\n    }\n    else {\n        // return elem itself if already a node\n        return elem;\n    }\n}\n// Converts CSS bezier string to bezier floats\nexport function parseBezierString(bezierString) {\n    let valObj = pennerEasings.filter(e => e.name == bezierString);\n    let vals;\n    if (valObj[0]) {\n        vals = valObj[0].value;\n    }\n    else {\n        bezierString = bezierString.split(/([^\\(-\\)]*)/);\n        bezierString = bezierString[3].split(/,(?![^()]*\\()/);\n        vals = bezierString.map((x) => { return parseFloat(x); });\n    }\n    if (Array.isArray(vals) && vals.length == 4)\n        return vals;\n    else\n        throw \"easing string is invalid.\";\n}\n// ES6 version of gre/bezier-easing \n// https://github.com/gre/bezier-easing/blob/master/src/index.js\nexport function bezierEasing(mX1, mY1, mX2, mY2) {\n    let newton_iterations = 4;\n    let newton_min_slope = 0.001;\n    let subdivision_precision = 0.0000001;\n    let subdivision_max_iterations = 10;\n    let kSplineTableSize = 11;\n    let kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);\n    let float32ArraySupported = typeof Float32Array === 'function';\n    function A(aA1, aA2) { return 1.0 - 3.0 * aA2 + 3.0 * aA1; }\n    function B(aA1, aA2) { return 3.0 * aA2 - 6.0 * aA1; }\n    function C(aA1) { return 3.0 * aA1; }\n    function calcBezier(aT, aA1, aA2) { return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT; }\n    function getSlope(aT, aA1, aA2) { return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1); }\n    function binarySubdivide(aX, aA, aB, mX1, mX2) {\n        let currentX, currentT, i = 0;\n        do {\n            currentT = aA + (aB - aA) / 2.0;\n            currentX = calcBezier(currentT, mX1, mX2) - aX;\n            if (currentX > 0.0) {\n                aB = currentT;\n            }\n            else {\n                aA = currentT;\n            }\n        } while (Math.abs(currentX) > subdivision_precision && ++i < subdivision_max_iterations);\n        return currentT;\n    }\n    function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {\n        for (let i = 0; i < newton_iterations; ++i) {\n            let currentSlope = getSlope(aGuessT, mX1, mX2);\n            if (currentSlope === 0.0) {\n                return aGuessT;\n            }\n            let currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n            aGuessT -= currentX / currentSlope;\n        }\n        return aGuessT;\n    }\n    function LinearEasing(x) { return x; }\n    if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {\n        throw new Error('bezier x values must be in [0, 1] range');\n    }\n    if (mX1 === mY1 && mX2 === mY2)\n        return LinearEasing;\n    let sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);\n    for (let i = 0; i < kSplineTableSize; ++i) {\n        sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\n    }\n    function getTForX(aX) {\n        let intervalStart = 0.0;\n        let currentSample = 1;\n        let lastSample = kSplineTableSize - 1;\n        for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {\n            intervalStart += kSampleStepSize;\n        }\n        --currentSample;\n        // Interpolate to provide an initial guess for t\n        let dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);\n        let guessForT = intervalStart + dist * kSampleStepSize;\n        let initialSlope = getSlope(guessForT, mX1, mX2);\n        if (initialSlope >= newton_min_slope) {\n            return newtonRaphsonIterate(aX, guessForT, mX1, mX2);\n        }\n        else if (initialSlope === 0.0) {\n            return guessForT;\n        }\n        else {\n            return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);\n        }\n    }\n    return (x) => {\n        if (x === 0 || x === 1)\n            return x;\n        return calcBezier(getTForX(x), mY1, mY2);\n    };\n}\n;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**************************************\n*            SlickScrollJS\n*           © Musab Hassan\n*\n*       Build with 'npm run build'\n*\n***************************************/\nimport { momentumScroll } from \"./momentumScroll/main\";\nimport { selectNode } from \"./utils\";\nexport default class slickScroll {\n    constructor() {\n        // mometumScrolling\n        this.momentumScroll = momentumScroll;\n    }\n    // The inView slickscroll function\n    inView(element) {\n        if (!element)\n            return;\n        if (NodeList.prototype.isPrototypeOf(element)) {\n            console.warn(\"Multiple elements are not selectable at inView\");\n            return;\n        }\n        let e = selectNode(element);\n        let parent = scrollableParent(e);\n        let parentViewTop = parent.getBoundingClientRect().top;\n        let parentViewBottom = parentViewTop + parent.getBoundingClientRect().height;\n        var elemTop = e.getBoundingClientRect().top;\n        var elemBottom = elemTop + (e.getBoundingClientRect().height);\n        // Returns boolean on if element is in view or not\n        return (((elemBottom <= parentViewBottom) && (elemTop >= parentViewTop)) &&\n            ((elemBottom > 0) && (elemTop <= window.innerHeight)));\n        // Go through parent list to find first scrollable parent\n        function scrollableParent(e) {\n            if (e == null)\n                return document.body;\n            let overflow = window.getComputedStyle(e).getPropertyValue('overflow');\n            if (e.scrollHeight > e.clientHeight && overflow != \"visible\" && overflow != \"hidden\")\n                return e;\n            return scrollableParent(e.parentNode);\n        }\n    }\n}\n"],"names":[],"sourceRoot":""}